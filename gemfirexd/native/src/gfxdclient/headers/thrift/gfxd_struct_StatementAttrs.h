/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#ifndef GFXD_STRUCT_STATEMENTATTRS_H
#define GFXD_STRUCT_STATEMENTATTRS_H


#include "gfxd_types.h"

#include "gfxd_struct_FieldDescriptor.h"
#include "gfxd_struct_Decimal.h"
#include "gfxd_struct_Timestamp.h"
#include "gfxd_struct_FieldValue.h"
#include "gfxd_struct_PDXNode.h"
#include "gfxd_struct_PDXObject.h"
#include "gfxd_struct_PDXSchemaNode.h"
#include "gfxd_struct_PDXSchema.h"
#include "gfxd_struct_JSONField.h"
#include "gfxd_struct_JSONNode.h"
#include "gfxd_struct_JSONObject.h"
#include "gfxd_struct_BlobChunk.h"
#include "gfxd_struct_ClobChunk.h"
#include "gfxd_struct_ServiceMetaData.h"
#include "gfxd_struct_ServiceMetaDataArgs.h"
#include "gfxd_struct_OpenConnectionArgs.h"
#include "gfxd_struct_ConnectionProperties.h"
#include "gfxd_struct_HostAddress.h"
#include "gfxd_struct_GFXDExceptionData.h"

namespace com { namespace pivotal { namespace gemfirexd { namespace thrift {

typedef struct _StatementAttrs__isset {
  _StatementAttrs__isset() : resultSetType(false), updatable(false), holdCursorsOverCommit(false), requireAutoIncCols(false), autoIncColumns(false), autoIncColumnNames(false), batchSize(true), fetchReverse(false), lobChunkSize(false), maxRows(false), maxFieldSize(false), timeout(false), cursorName(false), possibleDuplicate(false), poolable(false), doEscapeProcessing(false), pendingTransactionAttrs(false) {}
  bool resultSetType;
  bool updatable;
  bool holdCursorsOverCommit;
  bool requireAutoIncCols;
  bool autoIncColumns;
  bool autoIncColumnNames;
  bool batchSize;
  bool fetchReverse;
  bool lobChunkSize;
  bool maxRows;
  bool maxFieldSize;
  bool timeout;
  bool cursorName;
  bool possibleDuplicate;
  bool poolable;
  bool doEscapeProcessing;
  bool pendingTransactionAttrs;
} _StatementAttrs__isset;

class StatementAttrs {
 public:

  static const char* ascii_fingerprint; // = "175D389614293BA940AE9B14466CCFB5";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x5D,0x38,0x96,0x14,0x29,0x3B,0xA9,0x40,0xAE,0x9B,0x14,0x46,0x6C,0xCF,0xB5};

  StatementAttrs() : resultSetType(0), updatable(0), holdCursorsOverCommit(0), requireAutoIncCols(0), batchSize(1024), fetchReverse(0), lobChunkSize(0), maxRows(0), maxFieldSize(0), timeout(0), cursorName(), possibleDuplicate(0), poolable(0), doEscapeProcessing(0) {
  }

  virtual ~StatementAttrs() throw() {}

  int8_t resultSetType;
  bool updatable;
  bool holdCursorsOverCommit;
  bool requireAutoIncCols;
  std::vector<int32_t>  autoIncColumns;
  std::vector<std::string>  autoIncColumnNames;
  int32_t batchSize;
  bool fetchReverse;
  int32_t lobChunkSize;
  int32_t maxRows;
  int32_t maxFieldSize;
  int32_t timeout;
  std::string cursorName;
  bool possibleDuplicate;
  bool poolable;
  bool doEscapeProcessing;
  std::map<TransactionAttribute::type, bool>  pendingTransactionAttrs;

  _StatementAttrs__isset __isset;

  void __set_resultSetType(const int8_t val) {
    resultSetType = val;
    __isset.resultSetType = true;
  }

  void __set_updatable(const bool val) {
    updatable = val;
    __isset.updatable = true;
  }

  void __set_holdCursorsOverCommit(const bool val) {
    holdCursorsOverCommit = val;
    __isset.holdCursorsOverCommit = true;
  }

  void __set_requireAutoIncCols(const bool val) {
    requireAutoIncCols = val;
    __isset.requireAutoIncCols = true;
  }

  void __set_autoIncColumns(const std::vector<int32_t> & val) {
    autoIncColumns = val;
    __isset.autoIncColumns = true;
  }

  void __set_autoIncColumnNames(const std::vector<std::string> & val) {
    autoIncColumnNames = val;
    __isset.autoIncColumnNames = true;
  }

  void __set_batchSize(const int32_t val) {
    batchSize = val;
    __isset.batchSize = true;
  }

  void __set_fetchReverse(const bool val) {
    fetchReverse = val;
    __isset.fetchReverse = true;
  }

  void __set_lobChunkSize(const int32_t val) {
    lobChunkSize = val;
    __isset.lobChunkSize = true;
  }

  void __set_maxRows(const int32_t val) {
    maxRows = val;
    __isset.maxRows = true;
  }

  void __set_maxFieldSize(const int32_t val) {
    maxFieldSize = val;
    __isset.maxFieldSize = true;
  }

  void __set_timeout(const int32_t val) {
    timeout = val;
    __isset.timeout = true;
  }

  void __set_cursorName(const std::string& val) {
    cursorName = val;
    __isset.cursorName = true;
  }

  void __set_possibleDuplicate(const bool val) {
    possibleDuplicate = val;
    __isset.possibleDuplicate = true;
  }

  void __set_poolable(const bool val) {
    poolable = val;
    __isset.poolable = true;
  }

  void __set_doEscapeProcessing(const bool val) {
    doEscapeProcessing = val;
    __isset.doEscapeProcessing = true;
  }

  void __set_pendingTransactionAttrs(const std::map<TransactionAttribute::type, bool> & val) {
    pendingTransactionAttrs = val;
    __isset.pendingTransactionAttrs = true;
  }

  bool operator == (const StatementAttrs & rhs) const
  {
    if (__isset.resultSetType != rhs.__isset.resultSetType)
      return false;
    else if (__isset.resultSetType && !(resultSetType == rhs.resultSetType))
      return false;
    if (__isset.updatable != rhs.__isset.updatable)
      return false;
    else if (__isset.updatable && !(updatable == rhs.updatable))
      return false;
    if (__isset.holdCursorsOverCommit != rhs.__isset.holdCursorsOverCommit)
      return false;
    else if (__isset.holdCursorsOverCommit && !(holdCursorsOverCommit == rhs.holdCursorsOverCommit))
      return false;
    if (__isset.requireAutoIncCols != rhs.__isset.requireAutoIncCols)
      return false;
    else if (__isset.requireAutoIncCols && !(requireAutoIncCols == rhs.requireAutoIncCols))
      return false;
    if (__isset.autoIncColumns != rhs.__isset.autoIncColumns)
      return false;
    else if (__isset.autoIncColumns && !(autoIncColumns == rhs.autoIncColumns))
      return false;
    if (__isset.autoIncColumnNames != rhs.__isset.autoIncColumnNames)
      return false;
    else if (__isset.autoIncColumnNames && !(autoIncColumnNames == rhs.autoIncColumnNames))
      return false;
    if (__isset.batchSize != rhs.__isset.batchSize)
      return false;
    else if (__isset.batchSize && !(batchSize == rhs.batchSize))
      return false;
    if (__isset.fetchReverse != rhs.__isset.fetchReverse)
      return false;
    else if (__isset.fetchReverse && !(fetchReverse == rhs.fetchReverse))
      return false;
    if (__isset.lobChunkSize != rhs.__isset.lobChunkSize)
      return false;
    else if (__isset.lobChunkSize && !(lobChunkSize == rhs.lobChunkSize))
      return false;
    if (__isset.maxRows != rhs.__isset.maxRows)
      return false;
    else if (__isset.maxRows && !(maxRows == rhs.maxRows))
      return false;
    if (__isset.maxFieldSize != rhs.__isset.maxFieldSize)
      return false;
    else if (__isset.maxFieldSize && !(maxFieldSize == rhs.maxFieldSize))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    if (__isset.cursorName != rhs.__isset.cursorName)
      return false;
    else if (__isset.cursorName && !(cursorName == rhs.cursorName))
      return false;
    if (__isset.possibleDuplicate != rhs.__isset.possibleDuplicate)
      return false;
    else if (__isset.possibleDuplicate && !(possibleDuplicate == rhs.possibleDuplicate))
      return false;
    if (__isset.poolable != rhs.__isset.poolable)
      return false;
    else if (__isset.poolable && !(poolable == rhs.poolable))
      return false;
    if (__isset.doEscapeProcessing != rhs.__isset.doEscapeProcessing)
      return false;
    else if (__isset.doEscapeProcessing && !(doEscapeProcessing == rhs.doEscapeProcessing))
      return false;
    if (__isset.pendingTransactionAttrs != rhs.__isset.pendingTransactionAttrs)
      return false;
    else if (__isset.pendingTransactionAttrs && !(pendingTransactionAttrs == rhs.pendingTransactionAttrs))
      return false;
    return true;
  }
  bool operator != (const StatementAttrs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StatementAttrs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StatementAttrs &a, StatementAttrs &b);

}}}} // namespace

#endif
