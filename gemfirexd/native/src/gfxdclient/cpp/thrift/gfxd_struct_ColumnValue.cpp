/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/*
 * Changes for GemFireXD distributed data platform.
 *
 * Portions Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>

#include "gfxd_struct_ColumnValue.h"

#include <algorithm>

#include "Utils.h"

namespace com { namespace pivotal { namespace gemfirexd { namespace thrift {

const char* ColumnValue::ascii_fingerprint = "6BF6A87FFEB79DA83293FCF6CE0D5BAD";
const uint8_t ColumnValue::binary_fingerprint[16] = {0x6B,0xF6,0xA8,0x7F,0xFE,0xB7,0x9D,0xA8,0x32,0x93,0xFC,0xF6,0xCE,0x0D,0x5B,0xAD};

void ColumnValue::copyFields(const ColumnValue& other) {
  m_uval = other.m_uval;
  switch (m_type) {
    case GFXDType::VARCHAR:
    case GFXDType::BINARY:
    case GFXDType::JAVA_OBJECT:
      m_uval.string_binary_java_val = new std::string(
          *other.m_uval.string_binary_java_val);
      break;
    case GFXDType::DECIMAL:
      delete m_uval.decimal_val;
      m_uval.decimal_val = new Decimal(
          *other.m_uval.decimal_val);
      break;
    case GFXDType::BLOB:
      m_uval.blob_val = new BlobChunk(
          *other.m_uval.blob_val);
      break;
    case GFXDType::CLOB:
      m_uval.clob_val = new ClobChunk(
          *other.m_uval.clob_val);
      break;
    case GFXDType::JSON_OBJECT:
      m_uval.json_val = new JSONObject(
          *other.m_uval.json_val);
      break;
    case GFXDType::PDX_OBJECT:
      m_uval.pdx_val = new PDXObject(
          *other.m_uval.pdx_val);
      break;
    default:
      break;
  }
}

void ColumnValue::clearValue() throw() {
  switch (m_type) {
    case GFXDType::OTHER:
      return;
    case GFXDType::VARCHAR:
    case GFXDType::BINARY:
    case GFXDType::JAVA_OBJECT:
      delete m_uval.string_binary_java_val;
      m_uval.string_binary_java_val = NULL;
      break;
    case GFXDType::DECIMAL:
      delete m_uval.decimal_val;
      m_uval.decimal_val = NULL;
      break;
    case GFXDType::BLOB:
      delete m_uval.blob_val;
      m_uval.blob_val = NULL;
      break;
    case GFXDType::CLOB:
      delete m_uval.clob_val;
      m_uval.clob_val = NULL;
      break;
    case GFXDType::JSON_OBJECT:
      delete m_uval.json_val;
      m_uval.json_val = NULL;
      break;
    case GFXDType::PDX_OBJECT:
      delete m_uval.pdx_val;
      m_uval.pdx_val = NULL;
      break;
    default:
      break;
  }
}

uint32_t ColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  bool firstIter = true;
  while (true)
  {
    if (!firstIter) {
      clearValue();
    }
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(m_uval.bool_val);
          m_type = GFXDType::BOOLEAN;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(m_uval.byte_val);
          m_type = GFXDType::TINYINT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(m_uval.i16_val);
          m_type = GFXDType::SMALLINT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(m_uval.i32_val);
          m_type = GFXDType::INTEGER;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(m_uval.i64_val);
          m_type = GFXDType::BIGINT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t i;
          xfer += iprot->readI32(i);
          m_uval.float_val = client::Utils::int32ToFloat(i);
          m_type = GFXDType::FLOAT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(m_uval.double_val);
          m_type = GFXDType::DOUBLE;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          m_uval.string_binary_java_val = new std::string();
          m_type = GFXDType::VARCHAR;
          xfer += iprot->readString(*m_uval.string_binary_java_val);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.decimal_val = new Decimal();
          m_type = GFXDType::DECIMAL;
          xfer += m_uval.decimal_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          DateTime d;
          xfer += d.read(iprot);
          m_uval.date_time_epoch_val = d.secsSinceEpoch;
          m_type = GFXDType::DATE;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          DateTime t;
          xfer += t.read(iprot);
          m_uval.date_time_epoch_val = t.secsSinceEpoch;
          m_type = GFXDType::TIME;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          Timestamp ts;
          xfer += ts.read(iprot);
          m_uval.timestamp_val.epochTime = ts.secsSinceEpoch;
          m_uval.timestamp_val.nanos = ts.nanos;
          m_type = GFXDType::TIMESTAMP;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          m_uval.string_binary_java_val = new std::string();
          m_type = GFXDType::BINARY;
          xfer += iprot->readBinary(*m_uval.string_binary_java_val);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.blob_val = new BlobChunk();
          m_type = GFXDType::BLOB;
          xfer += m_uval.blob_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.clob_val = new ClobChunk();
          m_type = GFXDType::CLOB;
          xfer += m_uval.clob_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(m_uval.null_val);
          m_uval.null_val = true;
          m_type = GFXDType::NULLTYPE;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.pdx_val = new PDXObject();
          m_type = GFXDType::PDX_OBJECT;
          xfer += m_uval.pdx_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.json_val = new JSONObject();
          m_type = GFXDType::JSON_OBJECT;
          xfer += m_uval.json_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          m_uval.string_binary_java_val = new std::string();
          m_type = GFXDType::JAVA_OBJECT;
          xfer += iprot->readBinary(*m_uval.string_binary_java_val);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
    firstIter = false;
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnValue");

  switch (m_type) {
    case GFXDType::BOOLEAN:
      xfer += oprot->writeFieldBegin("bool_val",
          ::apache::thrift::protocol::T_BOOL, 1);
      xfer += oprot->writeBool(m_uval.bool_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::TINYINT:
      xfer += oprot->writeFieldBegin("byte_val",
          ::apache::thrift::protocol::T_BYTE, 2);
      xfer += oprot->writeByte(m_uval.byte_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::SMALLINT:
      xfer += oprot->writeFieldBegin("i16_val",
          ::apache::thrift::protocol::T_I16, 3);
      xfer += oprot->writeI16(m_uval.i16_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::INTEGER:
      xfer += oprot->writeFieldBegin("i32_val",
          ::apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32(m_uval.i32_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::BIGINT:
      xfer += oprot->writeFieldBegin("i64_val",
          ::apache::thrift::protocol::T_I64, 5);
      xfer += oprot->writeI64(m_uval.i64_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::FLOAT:
      xfer += oprot->writeFieldBegin("float_val",
          ::apache::thrift::protocol::T_I32, 6);
      xfer += oprot->writeI32(client::Utils::float2Int32(m_uval.float_val));
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::DOUBLE:
      xfer += oprot->writeFieldBegin("double_val",
          ::apache::thrift::protocol::T_DOUBLE, 7);
      xfer += oprot->writeDouble(m_uval.double_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::VARCHAR:
      xfer += oprot->writeFieldBegin("string_val",
          ::apache::thrift::protocol::T_STRING, 8);
      xfer += oprot->writeString(*m_uval.string_binary_java_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::DECIMAL:
      xfer += oprot->writeFieldBegin("decimal_val",
          ::apache::thrift::protocol::T_STRUCT, 9);
      xfer += m_uval.decimal_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::DATE:
      xfer += oprot->writeFieldBegin("date_val",
          ::apache::thrift::protocol::T_STRUCT, 10);
      xfer += DateTime(m_uval.date_time_epoch_val).write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::TIME:
      xfer += oprot->writeFieldBegin("time_val",
          ::apache::thrift::protocol::T_STRUCT, 11);
      xfer += DateTime(m_uval.date_time_epoch_val).write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::TIMESTAMP:
      xfer += oprot->writeFieldBegin("timestamp_val",
          ::apache::thrift::protocol::T_STRUCT, 12);
      xfer += Timestamp(m_uval.timestamp_val.epochTime,
          m_uval.timestamp_val.nanos).write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::BINARY:
      xfer += oprot->writeFieldBegin("binary_val",
          ::apache::thrift::protocol::T_STRING, 13);
      xfer += oprot->writeBinary(*m_uval.string_binary_java_val);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::BLOB:
      xfer += oprot->writeFieldBegin("blob_val",
          ::apache::thrift::protocol::T_STRUCT, 14);
      xfer += m_uval.blob_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::CLOB:
      xfer += oprot->writeFieldBegin("clob_val",
          ::apache::thrift::protocol::T_STRUCT, 15);
      xfer += m_uval.clob_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::NULLTYPE:
      xfer += oprot->writeFieldBegin("null_val",
          ::apache::thrift::protocol::T_BOOL, 16);
      xfer += oprot->writeBool(true);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::PDX_OBJECT:
      xfer += oprot->writeFieldBegin("pdx_val",
          ::apache::thrift::protocol::T_STRUCT, 17);
      xfer += m_uval.pdx_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::JSON_OBJECT:
      xfer += oprot->writeFieldBegin("json_val",
          ::apache::thrift::protocol::T_STRUCT, 18);
      xfer += m_uval.json_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case GFXDType::JAVA_OBJECT:
      xfer += oprot->writeFieldBegin("java_val",
          ::apache::thrift::protocol::T_STRING, 19);
      xfer += oprot->writeBinary(*m_uval.string_binary_java_val);
      xfer += oprot->writeFieldEnd();
      break;
    default:
      break;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void ColumnValue::swap(ColumnValue& other) {
  using ::std::swap;
  swap(m_uval, other.m_uval);
  swap(m_type, other.m_type);
}

void swap(ColumnValue &a, ColumnValue &b) {
  a.swap(b);
}

}}}} // namespace
