/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>

#include "gfxd_struct_ServiceMetaData.h"

#include <algorithm>

namespace com { namespace pivotal { namespace gemfirexd { namespace thrift {

const char* ServiceMetaData::ascii_fingerprint = "A811C5DBBEB236F7C60C89FD8360EFD1";
const uint8_t ServiceMetaData::binary_fingerprint[16] = {0xA8,0x11,0xC5,0xDB,0xBE,0xB2,0x36,0xF7,0xC6,0x0C,0x89,0xFD,0x83,0x60,0xEF,0xD1};

uint32_t ServiceMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_productName = false;
  bool isset_productVersion = false;
  bool isset_productMajorVersion = false;
  bool isset_productMinorVersion = false;
  bool isset_jdbcMajorVersion = false;
  bool isset_jdbcMinorVersion = false;
  bool isset_identifierQuote = false;
  bool isset_sqlKeywords = false;
  bool isset_numericFunctions = false;
  bool isset_stringFunctions = false;
  bool isset_systemFunctions = false;
  bool isset_dateTimeFunctions = false;
  bool isset_searchStringEscape = false;
  bool isset_supportedCONVERT = false;
  bool isset_schemaTerm = false;
  bool isset_procedureTerm = false;
  bool isset_catalogTerm = false;
  bool isset_catalogSeparator = false;
  bool isset_maxBinaryLiteralLength = false;
  bool isset_maxCharLiteralLength = false;
  bool isset_maxColumnsInGroupBy = false;
  bool isset_maxColumnsInIndex = false;
  bool isset_maxColumnsInOrderBy = false;
  bool isset_maxColumnsInSelect = false;
  bool isset_maxColumnsInTable = false;
  bool isset_maxConnections = false;
  bool isset_maxIndexLength = false;
  bool isset_maxRowSize = false;
  bool isset_maxStatementLength = false;
  bool isset_maxOpenStatements = false;
  bool isset_maxTableNamesInSelect = false;
  bool isset_maxColumnNameLength = false;
  bool isset_maxCursorNameLength = false;
  bool isset_maxSchemaNameLength = false;
  bool isset_maxProcedureNameLength = false;
  bool isset_maxCatalogNameLength = false;
  bool isset_maxTableNameLength = false;
  bool isset_maxUserNameLength = false;
  bool isset_defaultTransactionIsolation = false;
  bool isset_defaultResultSetType = false;
  bool isset_defaultResultSetHoldabilityHoldCursorsOverCommit = false;
  bool isset_sqlStateIsXOpen = false;
  bool isset_catalogAtStart = false;
  bool isset_transactionDefaults = false;
  bool isset_rowIdLifeTime = false;
  bool isset_supportedFeatures = false;
  bool isset_featuresWithParams = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productName);
          isset_productName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productVersion);
          isset_productVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->productMajorVersion);
          isset_productMajorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->productMinorVersion);
          isset_productMinorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jdbcMajorVersion);
          isset_jdbcMajorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jdbcMinorVersion);
          isset_jdbcMinorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifierQuote);
          isset_identifierQuote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqlKeywords.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->sqlKeywords.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += iprot->readString(this->sqlKeywords[_i109]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sqlKeywords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->numericFunctions.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _etype113;
            xfer += iprot->readListBegin(_etype113, _size110);
            this->numericFunctions.resize(_size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              xfer += iprot->readString(this->numericFunctions[_i114]);
            }
            xfer += iprot->readListEnd();
          }
          isset_numericFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stringFunctions.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readListBegin(_etype118, _size115);
            this->stringFunctions.resize(_size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              xfer += iprot->readString(this->stringFunctions[_i119]);
            }
            xfer += iprot->readListEnd();
          }
          isset_stringFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->systemFunctions.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->systemFunctions.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += iprot->readString(this->systemFunctions[_i124]);
            }
            xfer += iprot->readListEnd();
          }
          isset_systemFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dateTimeFunctions.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->dateTimeFunctions.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readString(this->dateTimeFunctions[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dateTimeFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->searchStringEscape);
          isset_searchStringEscape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extraNameCharacters);
          this->__isset.extraNameCharacters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->supportedCONVERT.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _ktype131;
            ::apache::thrift::protocol::TType _vtype132;
            xfer += iprot->readMapBegin(_ktype131, _vtype132, _size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              GFXDType::type _key135;
              int32_t ecast137;
              xfer += iprot->readI32(ecast137);
              _key135 = (GFXDType::type)ecast137;
              std::set<GFXDType::type> & _val136 = this->supportedCONVERT[_key135];
              {
                _val136.clear();
                uint32_t _size138;
                ::apache::thrift::protocol::TType _etype141;
                xfer += iprot->readSetBegin(_etype141, _size138);
                uint32_t _i142;
                for (_i142 = 0; _i142 < _size138; ++_i142)
                {
                  GFXDType::type _elem143;
                  int32_t ecast144;
                  xfer += iprot->readI32(ecast144);
                  _elem143 = (GFXDType::type)ecast144;
                  _val136.insert(_elem143);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_supportedCONVERT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaTerm);
          isset_schemaTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->procedureTerm);
          isset_procedureTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogTerm);
          isset_catalogTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogSeparator);
          isset_catalogSeparator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxBinaryLiteralLength);
          isset_maxBinaryLiteralLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCharLiteralLength);
          isset_maxCharLiteralLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInGroupBy);
          isset_maxColumnsInGroupBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInIndex);
          isset_maxColumnsInIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInOrderBy);
          isset_maxColumnsInOrderBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInSelect);
          isset_maxColumnsInSelect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInTable);
          isset_maxColumnsInTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxConnections);
          isset_maxConnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxIndexLength);
          isset_maxIndexLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRowSize);
          isset_maxRowSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxStatementLength);
          isset_maxStatementLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxOpenStatements);
          isset_maxOpenStatements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTableNamesInSelect);
          isset_maxTableNamesInSelect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnNameLength);
          isset_maxColumnNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCursorNameLength);
          isset_maxCursorNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSchemaNameLength);
          isset_maxSchemaNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxProcedureNameLength);
          isset_maxProcedureNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCatalogNameLength);
          isset_maxCatalogNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTableNameLength);
          isset_maxTableNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxUserNameLength);
          isset_maxUserNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->defaultTransactionIsolation);
          isset_defaultTransactionIsolation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->defaultResultSetType);
          isset_defaultResultSetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->defaultResultSetHoldabilityHoldCursorsOverCommit);
          isset_defaultResultSetHoldabilityHoldCursorsOverCommit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sqlStateIsXOpen);
          isset_sqlStateIsXOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->catalogAtStart);
          isset_catalogAtStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transactionDefaults.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _ktype146;
            ::apache::thrift::protocol::TType _vtype147;
            xfer += iprot->readMapBegin(_ktype146, _vtype147, _size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              TransactionAttribute::type _key150;
              int32_t ecast152;
              xfer += iprot->readI32(ecast152);
              _key150 = (TransactionAttribute::type)ecast152;
              bool& _val151 = this->transactionDefaults[_key150];
              xfer += iprot->readBool(_val151);
            }
            xfer += iprot->readMapEnd();
          }
          isset_transactionDefaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 46:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast153;
          xfer += iprot->readI32(ecast153);
          this->rowIdLifeTime = (RowIdLifetime::type)ecast153;
          isset_rowIdLifeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 47:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->supportedFeatures.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readSetBegin(_etype157, _size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              ServiceFeature::type _elem159;
              int32_t ecast160;
              xfer += iprot->readI32(ecast160);
              _elem159 = (ServiceFeature::type)ecast160;
              this->supportedFeatures.insert(_elem159);
            }
            xfer += iprot->readSetEnd();
          }
          isset_supportedFeatures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 48:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->featuresWithParams.clear();
            uint32_t _size161;
            ::apache::thrift::protocol::TType _ktype162;
            ::apache::thrift::protocol::TType _vtype163;
            xfer += iprot->readMapBegin(_ktype162, _vtype163, _size161);
            uint32_t _i165;
            for (_i165 = 0; _i165 < _size161; ++_i165)
            {
              ServiceFeatureParameterized::type _key166;
              int32_t ecast168;
              xfer += iprot->readI32(ecast168);
              _key166 = (ServiceFeatureParameterized::type)ecast168;
              std::vector<int32_t> & _val167 = this->featuresWithParams[_key166];
              {
                _val167.clear();
                uint32_t _size169;
                ::apache::thrift::protocol::TType _etype172;
                xfer += iprot->readListBegin(_etype172, _size169);
                _val167.resize(_size169);
                uint32_t _i173;
                for (_i173 = 0; _i173 < _size169; ++_i173)
                {
                  xfer += iprot->readI32(_val167[_i173]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_featuresWithParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_productName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productMajorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productMinorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jdbcMajorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jdbcMinorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_identifierQuote)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sqlKeywords)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numericFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stringFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_systemFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dateTimeFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_searchStringEscape)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedCONVERT)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schemaTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_procedureTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogSeparator)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxBinaryLiteralLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCharLiteralLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInGroupBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInOrderBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInSelect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInTable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxConnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxIndexLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxRowSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStatementLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxOpenStatements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTableNamesInSelect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCursorNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxSchemaNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxProcedureNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCatalogNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTableNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxUserNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultTransactionIsolation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultResultSetType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultResultSetHoldabilityHoldCursorsOverCommit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sqlStateIsXOpen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogAtStart)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_transactionDefaults)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rowIdLifeTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedFeatures)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_featuresWithParams)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServiceMetaData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceMetaData");

  xfer += oprot->writeFieldBegin("productName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->productName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productVersion", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->productVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productMajorVersion", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->productMajorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productMinorVersion", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->productMinorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jdbcMajorVersion", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->jdbcMajorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jdbcMinorVersion", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->jdbcMinorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifierQuote", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->identifierQuote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlKeywords", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sqlKeywords.size()));
    std::vector<std::string> ::const_iterator _iter174;
    for (_iter174 = this->sqlKeywords.begin(); _iter174 != this->sqlKeywords.end(); ++_iter174)
    {
      xfer += oprot->writeString((*_iter174));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numericFunctions", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->numericFunctions.size()));
    std::vector<std::string> ::const_iterator _iter175;
    for (_iter175 = this->numericFunctions.begin(); _iter175 != this->numericFunctions.end(); ++_iter175)
    {
      xfer += oprot->writeString((*_iter175));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringFunctions", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stringFunctions.size()));
    std::vector<std::string> ::const_iterator _iter176;
    for (_iter176 = this->stringFunctions.begin(); _iter176 != this->stringFunctions.end(); ++_iter176)
    {
      xfer += oprot->writeString((*_iter176));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemFunctions", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->systemFunctions.size()));
    std::vector<std::string> ::const_iterator _iter177;
    for (_iter177 = this->systemFunctions.begin(); _iter177 != this->systemFunctions.end(); ++_iter177)
    {
      xfer += oprot->writeString((*_iter177));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dateTimeFunctions", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dateTimeFunctions.size()));
    std::vector<std::string> ::const_iterator _iter178;
    for (_iter178 = this->dateTimeFunctions.begin(); _iter178 != this->dateTimeFunctions.end(); ++_iter178)
    {
      xfer += oprot->writeString((*_iter178));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchStringEscape", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->searchStringEscape);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extraNameCharacters) {
    xfer += oprot->writeFieldBegin("extraNameCharacters", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->extraNameCharacters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("supportedCONVERT", ::apache::thrift::protocol::T_MAP, 15);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->supportedCONVERT.size()));
    std::map<GFXDType::type, std::set<GFXDType::type> > ::const_iterator _iter179;
    for (_iter179 = this->supportedCONVERT.begin(); _iter179 != this->supportedCONVERT.end(); ++_iter179)
    {
      xfer += oprot->writeI32((int32_t)_iter179->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter179->second.size()));
        std::set<GFXDType::type> ::const_iterator _iter180;
        for (_iter180 = _iter179->second.begin(); _iter180 != _iter179->second.end(); ++_iter180)
        {
          xfer += oprot->writeI32((int32_t)(*_iter180));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaTerm", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->schemaTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("procedureTerm", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->procedureTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogTerm", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->catalogTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogSeparator", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->catalogSeparator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxBinaryLiteralLength", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->maxBinaryLiteralLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCharLiteralLength", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->maxCharLiteralLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInGroupBy", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->maxColumnsInGroupBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInIndex", ::apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->maxColumnsInIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInOrderBy", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->maxColumnsInOrderBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInSelect", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->maxColumnsInSelect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInTable", ::apache::thrift::protocol::T_I32, 26);
  xfer += oprot->writeI32(this->maxColumnsInTable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxConnections", ::apache::thrift::protocol::T_I32, 27);
  xfer += oprot->writeI32(this->maxConnections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxIndexLength", ::apache::thrift::protocol::T_I32, 28);
  xfer += oprot->writeI32(this->maxIndexLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxRowSize", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->maxRowSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStatementLength", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->maxStatementLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxOpenStatements", ::apache::thrift::protocol::T_I32, 31);
  xfer += oprot->writeI32(this->maxOpenStatements);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTableNamesInSelect", ::apache::thrift::protocol::T_I32, 32);
  xfer += oprot->writeI32(this->maxTableNamesInSelect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnNameLength", ::apache::thrift::protocol::T_I32, 33);
  xfer += oprot->writeI32(this->maxColumnNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCursorNameLength", ::apache::thrift::protocol::T_I32, 34);
  xfer += oprot->writeI32(this->maxCursorNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSchemaNameLength", ::apache::thrift::protocol::T_I32, 35);
  xfer += oprot->writeI32(this->maxSchemaNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxProcedureNameLength", ::apache::thrift::protocol::T_I32, 36);
  xfer += oprot->writeI32(this->maxProcedureNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCatalogNameLength", ::apache::thrift::protocol::T_I32, 37);
  xfer += oprot->writeI32(this->maxCatalogNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTableNameLength", ::apache::thrift::protocol::T_I32, 38);
  xfer += oprot->writeI32(this->maxTableNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxUserNameLength", ::apache::thrift::protocol::T_I32, 39);
  xfer += oprot->writeI32(this->maxUserNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultTransactionIsolation", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->defaultTransactionIsolation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultResultSetType", ::apache::thrift::protocol::T_BYTE, 41);
  xfer += oprot->writeByte(this->defaultResultSetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultResultSetHoldabilityHoldCursorsOverCommit", ::apache::thrift::protocol::T_BOOL, 42);
  xfer += oprot->writeBool(this->defaultResultSetHoldabilityHoldCursorsOverCommit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlStateIsXOpen", ::apache::thrift::protocol::T_BOOL, 43);
  xfer += oprot->writeBool(this->sqlStateIsXOpen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogAtStart", ::apache::thrift::protocol::T_BOOL, 44);
  xfer += oprot->writeBool(this->catalogAtStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionDefaults", ::apache::thrift::protocol::T_MAP, 45);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->transactionDefaults.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter181;
    for (_iter181 = this->transactionDefaults.begin(); _iter181 != this->transactionDefaults.end(); ++_iter181)
    {
      xfer += oprot->writeI32((int32_t)_iter181->first);
      xfer += oprot->writeBool(_iter181->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rowIdLifeTime", ::apache::thrift::protocol::T_I32, 46);
  xfer += oprot->writeI32((int32_t)this->rowIdLifeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportedFeatures", ::apache::thrift::protocol::T_SET, 47);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->supportedFeatures.size()));
    std::set<ServiceFeature::type> ::const_iterator _iter182;
    for (_iter182 = this->supportedFeatures.begin(); _iter182 != this->supportedFeatures.end(); ++_iter182)
    {
      xfer += oprot->writeI32((int32_t)(*_iter182));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("featuresWithParams", ::apache::thrift::protocol::T_MAP, 48);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->featuresWithParams.size()));
    std::map<ServiceFeatureParameterized::type, std::vector<int32_t> > ::const_iterator _iter183;
    for (_iter183 = this->featuresWithParams.begin(); _iter183 != this->featuresWithParams.end(); ++_iter183)
    {
      xfer += oprot->writeI32((int32_t)_iter183->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter183->second.size()));
        std::vector<int32_t> ::const_iterator _iter184;
        for (_iter184 = _iter183->second.begin(); _iter184 != _iter183->second.end(); ++_iter184)
        {
          xfer += oprot->writeI32((*_iter184));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceMetaData &a, ServiceMetaData &b) {
  using ::std::swap;
  swap(a.productName, b.productName);
  swap(a.productVersion, b.productVersion);
  swap(a.productMajorVersion, b.productMajorVersion);
  swap(a.productMinorVersion, b.productMinorVersion);
  swap(a.jdbcMajorVersion, b.jdbcMajorVersion);
  swap(a.jdbcMinorVersion, b.jdbcMinorVersion);
  swap(a.identifierQuote, b.identifierQuote);
  swap(a.sqlKeywords, b.sqlKeywords);
  swap(a.numericFunctions, b.numericFunctions);
  swap(a.stringFunctions, b.stringFunctions);
  swap(a.systemFunctions, b.systemFunctions);
  swap(a.dateTimeFunctions, b.dateTimeFunctions);
  swap(a.searchStringEscape, b.searchStringEscape);
  swap(a.extraNameCharacters, b.extraNameCharacters);
  swap(a.supportedCONVERT, b.supportedCONVERT);
  swap(a.schemaTerm, b.schemaTerm);
  swap(a.procedureTerm, b.procedureTerm);
  swap(a.catalogTerm, b.catalogTerm);
  swap(a.catalogSeparator, b.catalogSeparator);
  swap(a.maxBinaryLiteralLength, b.maxBinaryLiteralLength);
  swap(a.maxCharLiteralLength, b.maxCharLiteralLength);
  swap(a.maxColumnsInGroupBy, b.maxColumnsInGroupBy);
  swap(a.maxColumnsInIndex, b.maxColumnsInIndex);
  swap(a.maxColumnsInOrderBy, b.maxColumnsInOrderBy);
  swap(a.maxColumnsInSelect, b.maxColumnsInSelect);
  swap(a.maxColumnsInTable, b.maxColumnsInTable);
  swap(a.maxConnections, b.maxConnections);
  swap(a.maxIndexLength, b.maxIndexLength);
  swap(a.maxRowSize, b.maxRowSize);
  swap(a.maxStatementLength, b.maxStatementLength);
  swap(a.maxOpenStatements, b.maxOpenStatements);
  swap(a.maxTableNamesInSelect, b.maxTableNamesInSelect);
  swap(a.maxColumnNameLength, b.maxColumnNameLength);
  swap(a.maxCursorNameLength, b.maxCursorNameLength);
  swap(a.maxSchemaNameLength, b.maxSchemaNameLength);
  swap(a.maxProcedureNameLength, b.maxProcedureNameLength);
  swap(a.maxCatalogNameLength, b.maxCatalogNameLength);
  swap(a.maxTableNameLength, b.maxTableNameLength);
  swap(a.maxUserNameLength, b.maxUserNameLength);
  swap(a.defaultTransactionIsolation, b.defaultTransactionIsolation);
  swap(a.defaultResultSetType, b.defaultResultSetType);
  swap(a.defaultResultSetHoldabilityHoldCursorsOverCommit, b.defaultResultSetHoldabilityHoldCursorsOverCommit);
  swap(a.sqlStateIsXOpen, b.sqlStateIsXOpen);
  swap(a.catalogAtStart, b.catalogAtStart);
  swap(a.transactionDefaults, b.transactionDefaults);
  swap(a.rowIdLifeTime, b.rowIdLifeTime);
  swap(a.supportedFeatures, b.supportedFeatures);
  swap(a.featuresWithParams, b.featuresWithParams);
  swap(a.__isset, b.__isset);
}

}}}} // namespace
