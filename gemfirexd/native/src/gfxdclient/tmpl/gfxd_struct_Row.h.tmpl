/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/*
 * Changes for GemFireXD distributed data platform.
 *
 * Portions Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

#ifndef GFXD_STRUCT_ROW_H
#define GFXD_STRUCT_ROW_H


#include "gfxd_types.h"

#include "gfxd_struct_FieldDescriptor.h"
#include "gfxd_struct_Decimal.h"
#include "gfxd_struct_Timestamp.h"
#include "gfxd_struct_FieldValue.h"
#include "gfxd_struct_PDXNode.h"
#include "gfxd_struct_PDXObject.h"
#include "gfxd_struct_PDXSchemaNode.h"
#include "gfxd_struct_PDXSchema.h"
#include "gfxd_struct_JSONField.h"
#include "gfxd_struct_JSONNode.h"
#include "gfxd_struct_JSONObject.h"
#include "gfxd_struct_BlobChunk.h"
#include "gfxd_struct_ClobChunk.h"
#include "gfxd_struct_ServiceMetaData.h"
#include "gfxd_struct_ServiceMetaDataArgs.h"
#include "gfxd_struct_OpenConnectionArgs.h"
#include "gfxd_struct_ConnectionProperties.h"
#include "gfxd_struct_HostAddress.h"
#include "gfxd_struct_GFXDExceptionData.h"
#include "gfxd_struct_StatementAttrs.h"
#include "gfxd_struct_DateTime.h"
#include "gfxd_struct_ColumnValue.h"
#include "gfxd_struct_ColumnDescriptor.h"

#include "common/ArrayList.h"

// removing dependency on boost for public headers
#ifndef BOOST_DYNAMIC_BITSET_FWD_HPP
#define BOOST_DYNAMIC_BITSET_FWD_HPP

#include <memory>

namespace boost {

  template <typename Block = unsigned long,
            typename Allocator = std::allocator<Block> >
  class dynamic_bitset;
}
#endif

namespace com { namespace pivotal { namespace gemfirexd { namespace thrift {

class Row {
protected:
  typedef boost::dynamic_bitset<unsigned long,
      std::allocator<unsigned long> > DynamicBitSet;

  com::pivotal::gemfirexd::ArrayList<ColumnValue> m_values;
  bool m_updatable;
  // tracks the updated columns that will be applied back to GemFireXD
  // server once the whole updated row is applied
  DynamicBitSet* m_changedColumns;

  // for placement new skip initialization of m_values
  Row(bool updatable) :
      m_values(true), m_updatable(updatable), m_changedColumns(0) {
  }

public:

  static const char* ascii_fingerprint; // = "5F2610F48CD6B8460ABF15799C138485";
  static const uint8_t binary_fingerprint[16]; // = {0x5F,0x26,0x10,0xF4,0x8C,0xD6,0xB8,0x46,0x0A,0xBF,0x15,0x79,0x9C,0x13,0x84,0x85};

  Row(): m_values(), m_updatable(false), m_changedColumns(0) {
  }

  Row(const size_t initialCapacity) :
      m_values(initialCapacity), m_updatable(false), m_changedColumns(0) {
  }

  Row(const Row& other);
  Row& operator=(const Row& other);

  // C++11 move constructor and move assignment operator
#if __cplusplus >= 201103L
  Row(Row&& other) : m_values(std::move(other.m_values)), m_updatable(
      other.m_updatable), m_changedColumns(other.m_changedColumns) {
    other.m_updatable = false;
    other.m_changedColumns = NULL;
  }

  Row& operator=(Row&& other) {
    m_values.swap(other.m_values);
    std::swap(m_updatable, other.m_updatable);
    std::swap(m_changedColumns, other.m_changedColumns);
    return *this;
  }
#endif

  virtual ~Row() throw();

  void clearChangedColumns();

  void clear();

  void resize(const size_t newSize) {
    m_values.resize(newSize);
  }

  void swap(Row& other);

  bool operator == (const Row & rhs) const {
    if (!(m_updatable == rhs.m_updatable))
      return false;
    if (!(m_values == rhs.m_values))
      return false;
    return true;
  }

  bool operator != (const Row &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Row & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Row &a, Row &b);

}}}} // namespace

#endif
